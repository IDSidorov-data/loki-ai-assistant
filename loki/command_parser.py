# loki/command_parser.py
"""
Десериализует и валидирует ответы LLM, извлекая структурированные
инструментальные вызовы (tool calls) из неструктурированного текста.

Этот модуль является критической точкой сопряжения между вероятностным
выводом LLM и детерминированной логикой приложения. Его основная задача —
обеспечить соблюдение контракта вывода, транслируя текстовый ответ модели
в кортеж (speakable_text, command_payload).

Реализован механизм "самовосстановления" для обработки распространенных
ошибок форматирования JSON, генерируемых LLM, что повышает общую
устойчивость системы.
"""
import re
import json
import logging
from typing import Optional, Dict, Any, Tuple

# Паттерн для извлечения JSON-блока. Используется нежадный квантификатор (.*?),
# чтобы корректно обрабатывать случаи, когда LLM галлюцинирует и генерирует
# несколько блоков [CMD], захватывая только первый. re.DOTALL обязателен,
# так как LLM может форматировать JSON с переносами строк.
COMMAND_JSON_PATTERN = re.compile(r"\[CMD\](.*?)\[/CMD\]", re.DOTALL)


def parse_llm_response(text: str) -> Tuple[str, Optional[Dict[str, Any]]]:
    """
    Извлекает JSON-объект команды и санирует текст для TTS.

    Функция атомарно выполняет две операции:
    1.  **Десериализация**: Ищет и пытается десериализовать JSON-payload из
        первого найденного блока [CMD]. Включает эвристику для исправления
        типичных синтаксических ошибок LLM (например, ключи без кавычек).
    2.  **Санитизация**: Идемпотентно удаляет все вхождения блока [CMD] из
        исходного текста, гарантируя, что служебная информация не попадет в TTS,
        даже если десериализация не удалась.

    Args:
        text: Сырой строковый вывод от LLM.

    Returns:
        Кортеж, содержащий:
        - (str): Очищенный текст, готовый для синтеза речи.
        - (Optional[Dict[str, Any]]): Валидный словарь с командой или None,
          если блок не найден или его содержимое не является валидным JSON.
    """
    if not isinstance(text, str):
        logging.warning(f"Некорректный тип данных на входе парсера: {type(text)}")
        return "", None

    command_json = None
    match = COMMAND_JSON_PATTERN.search(text)

    if match:
        json_str = match.group(1).strip()
        try:
            # Устойчивость к ошибкам LLM: исправляем JSON с неэкранированными ключами
            # и заменяем одинарные кавычки, что является частым артефактом генерации.
            json_str_healed = re.sub(
                r"([,{]\s*)(\w+)(\s*:)", r'\1"\2"\3', json_str.replace("'", '"')
            )
            command_json = json.loads(json_str_healed)
        except json.JSONDecodeError:
            logging.error(f"Сбой десериализации JSON-payload: {json_str}")
            # command_json остается None, выполнение команды будет пропущено.

    # Санитизация вывода для TTS. Удаляет блок [CMD] независимо от успеха
    # парсинга, обеспечивая чистоту аудио-ответа.
    text_to_speak = COMMAND_JSON_PATTERN.sub("", text).strip()

    return text_to_speak, command_json
